# 权限管理
## 一.需求描述
  由于后端ms有许多敏感且跟用户相关的信息需要配置之类的，比如课程的创建、ini的配置等等。在之前的设置中，只要有后端的权限，既可以操作所有的接口，为了防止工作人员的误操作，需要保证不同的人员只能拥有特定的接口操作权限。

## 二.技术概述
1.ms部署启动时将所有的ms后端接口全部更新。
  接口分为：模块接口和单个接口
  模块接口具有该模块下的所有接口权限。
  如admin/order  包含  admin/order/getInfo等等之类的单个接口
  模块接口的具体用途为： 
  后端编写接口时，一般会把所有性质类似的接口放在一个Controller中，当想要赋予这个Controller下的所有接口时，可以直接赋予模块接口，便于一次性操作。
   具体的数据库表如下图所示：



2.将用户登录后的email作为唯一性标识。
  具体的数据库表如下图：



3.将接口赋予角色，角色再赋予用户。
  角色的作用类似于运营、开发之类的抽象含义，即角色是一些权限的集合。
  如果用户拥有多个角色，则拥有的权限是这些角色拥有的权限的并集。
  具体的数据库表如下图：







  

## 三.技术实现
1.权限初始化
流程：

通过反射将所有的Controller、RestController注解的类class找出来，提取出模块接口即类上@RequestMapping标注的值,并对所有RequestMapping、GetMapping、PostMapping标注的方法的权限名字格式化后提取出来。
将模块接口和单个接口进行关联，Map结构
更新数据库：读取出当前数据库中所有有效的接口(status=1)，即之前的接口信息，然后与提取出来的最新的接口信息进行比对，进行update(将已经删除的接口status变为0)、add(新增接口)
问题：

    1.反射读取某个包下的文件时需要区分读取。

本地idea运行是保存为文件的形式，而上线则是运行jira包，两者使用反射读取信息时，使用的读取方式不同。具体可参考：https://github.com/wanghongfei/pkg-scanner

    2.失效的接口处理

比如某个接口为A，某个用户拥有A的权限，A之后被删除了，但是后来有加了一个接口和A同名，用户应该是不能访问A同名的接口的。（在之前的设计中存在这个问题）

   3.多机启动时的问题

多个机器启动时，如果A机器正在进行更新，B也在进行更新，两个读取到之前的接口信息是一样的，此时如果有接口a需要进行add。则A和B都会在自己的判断后进行add，由于权限的url不是unique的（业务逻辑来保证unique），此时会有两个相同的url进行插入。

   解决方案：

  1.引入redis的分布式锁：所有的初始化按顺序进行，这样A在更新后，基本上B不用再更新了，但是会做无用功。

  2.优化：只需要一个机器进行更新，所有未争抢到锁的机器放弃更新。但是会存在问题：

     (1)无法确定机器集群什么时候会启动，比如A先启动，lock->更新->unlock，B再启动，lock->更新→unlock。即A和B还是都会进行更新。

     解决方案：

     引入一个redis键。来记录是否已进行更新。目前设置的失效时间是5分钟，即在5分钟内所有的机器只会有一个机器进行初始化，其他的机器会跳过初始化环节。满足目前的ms需求。

    (2)A初始化，B不初始化。会导致B的内部缓存中关于权限的信息是滞后的，即上一次的权限信息，所以必须使B感知到权限进行了更新。

     解决方案：

     引入另一个redis键。来表示更新是否已经完成，当进行权限检测时，B的内部权限缓存器会检查自己内部的标志位isUpdate（默认是false）。如果为false表示内部还未更新，此时会去redis里检查redis的标志位，并根据这两个标志位来懒更新内存权限缓存。

2.缓存的引入
后台ms由于用户量不大，查表是可以解决所有的问题的。但是涉及的表共有5张，且权限的更改不会太频繁，所以引入缓存。

1.缓存的种类有：

权限的缓存：即AdminAuth表中所有有效的权限的缓存，由于涉及id和url的对应关系，且一旦机器部署后，权限信息是不会变更的，所以放入本地的缓存中，而不放入redis（放入redis需要做解析转化）。
用户的缓存：即用户所拥有的权限的缓存，目前是Map<String,String>结构（key为email，value为逗号分隔的url）。即用户请求过来后会首先从redis中查，查不到则从数据库中取，并存入redis中。更改用户权限后，删除用户缓存。
2.缓存设计的存在问题：

未引入角色的缓存。当删除角色或更改角色权限时会，会删除所有的用户缓存。
用户缓存的redis结构不够合理，取得url后，还要进行时间复杂度为O(n)的判断。
3.优化思路（未优化）：

    1.引入角色缓存 

    设置角色缓存，当角色信息变更后，无需删除全部的用户缓存，只需要删除与之有关的用户缓存即可。同时可以使从数据库中取得用户权限的速度更快。

   2.将用户缓存的结构设置为Set<String>结构，key为用户的email标识的特定值，这样权限检测时更快。

## 四.线上遇到的一些问题
1.用户表的email的唯一性保证。当前端多次请求时，可能会进行多次插入（设置unique、或分布式锁解决）。

2.权限初始化未完成便开始进行权限检测（原因是采用了静态启动的方式，后将权限初始化放置于Spring框架中进行）。