# 运行时数据区域

![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/17/5778d113-8e13-4c53-b5bf-801e58080b97-1584375173434.png)

## 程序计数器
记录正在执行虚拟机的字节码指令地址。（本地方法为空）

## Java 虚拟机栈
java方法在执行时会创建一个栈帧用户存放操作数栈，局部变量表，常量池引用等信息，方法的调用就是执行入栈和出栈的过程。

![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/17/8442519f-0b4d-48f4-8229-56f984363c69-1584375708954.png)

异常：
* 线程请求栈深度超过最大值：StackOverflowError
* 栈进行动态扩展无法申请到足够内存：OutOfMemoryError

## 本地方法栈
与java虚拟机栈类似，本地方法栈服务于本地方法。本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。


## 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）
垃圾回收算法一般采用分带回收，针对不同对象（新生代、老年代）采用不同的垃圾回收算法。

异常：
* 不需要连续内存，动态增加内存，增加失败：outOfMemoryError

## 方法区

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

异常：
* 不需要连续内存，动态增加内存，增加失败：outOfMemoryError

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。

## 运行时常量池

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

## 直接内存




