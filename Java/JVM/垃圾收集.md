# 垃圾收集

垃圾收集主要针对堆和方法区。程序计数器、虚拟机栈，本地方法栈属于线程私有，只存在于线程的生命周期内。

## 判断一个对象是否可以被回收
1. 引用计数法
    为对象添加一个引用计数器，对象增加一个引用时计数器+1，引用失效计数器-1，计时器为0时回收。
    问题：循环引用无法处理
2. 可达性分析
    通过GC Roots为起始点进行搜索，可达的对象是存活的，不可达的对象可被回收。
    GC Roots的选取：
    * 虚拟机栈的局部变量表所引用的对象
    * 本地方法栈中JNI中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法去中常量引用的对象

## 方法区的回收 & finalize()

### 方法区的回收
方法区主要存放永久带对象，对方法区的回收主要是对常量池的回收和对类的卸载。
对类的卸载需满足一下条件：
* 该类所有**实例**已经被回收
* 该类ClassLoader已被回收
* 该类对应的Class对象未被引用

### finalize()

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。

## 引用类型
1. 强引用
    被强引用关联的对象不会被回收。
```
Object obj = new Object();
```
2. 软引用
    被软引用关联的对象只有在**内存不够**的情况下才会被回收.
```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```
3. 弱引用
    下一次垃圾回收发生之前被回收
```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```
4. 虚引用
    又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是**能在这个对象被回收时收到一个系统通知**。
```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

## 垃圾回收算法

### 1.标记-清除
标记阶段：检测对象是否为活动对象，若是打上标记。
清除阶段：对象回收取消标志，把回收对象


