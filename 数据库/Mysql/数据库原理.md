# 数据库原理

## 事务
事务是指满足ACID特性的一组操作，可以通过commit提交一个事务，也可以通过rollback进行回滚。
![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585378969945-1585378970021.png)

## ACID
### 原子性
事务被事务一个不可分割的最小单元，事务的所有操作那么提交成功，要么全部失败回滚。
### 隔离性
一个事务的所有修改在最终提交之前，对于其他事务是不可见的。
### 一致性
数据库事务执行前后都保持一致性状态。
### 持久性
一旦事务提交，其所做的修改将会永远保存到数据库中。

![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585379828786-1585379828787.png)

msyql 默认自动提交模式,每个查询操作都会被当做一个事务并自动提交，可以使用start transction来开启事务。
```sql
START TRANSACTION;
# 帐号1的金额减去200， 帐号2的金额增加200
UPDATE bank SET balance = balance - 200.00 WHERE customer_id = 1;
UPDATE bank SET balance = balance + 200.00 WHERE customer_id = 2;
COMMIT;
```
1. 原子性：对于上面的两条sql语句，那么全部执行成功，要么全部回滚。
2. 隔离性：在并发情况下（事务1，事务2），若事务1执行到对balance-200，事务2去查询balance时，查到的仍是原来的balance。
3. 一致性：该事务执行前后，数据库都要是一致性状态。
4. 持久性：事务一旦执行，对数据库的修改是永久的。

## 并发一致性
如上所述，在并发情况下很难保证事务的隔离性，因此会出现以下问题。
### 丢失修改
T1和T2两个事务对一个数据进行修改，T1修改的数据可能被T2所覆盖。
![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585381362038-1585381362039.png)![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585381221535-1585381221539.png)

### 读脏数据
T1事务对某个值修改，然后T2对这个值进行读取，T1之后又进行了数据回滚，此时T2读到的数据为脏数据。

![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585381648109-1585381648112.png)

### 不可重复读
T1 先读数据A ，T2对数据修改，T1再次读A，两次读到的数据不同。

![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585381970288-1585381970291.png)

### 幻读
T1 读入一个区间数据(例如count)，T2插入数据，T1在读这个区间数据,两次得到数据不同。
![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585382269858-1585382269987.png)

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过**封锁**来实现，或使用数据库管理系统提供了事务的**隔离级别**。

## 封锁

### 粒度 
mysql提供了两种锁：行级锁、表锁。

### 类型
1. 读写锁
    * 互斥锁： X锁，写锁，一个事务对A加X锁，可以对A读写，其他事务无法操作。
    * 共享锁： S锁，读锁，一个事务对A加S锁，只能对A读，其他事务只能加S锁。

2. 意向锁
引入原因：当某个事务想要对一个表加锁时，需要












