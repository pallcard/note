# mysql 隔离级别

## 多版本并发控制

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想
MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。**脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。**为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。

### 几个概念

#### 版本号
1. 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
2. 事务版本号 TRX_ID：事务开始时的系统版本号。

#### 隐藏列

MVCC的每行记录后面都保存着两个隐藏的列

1. 创建版本号，创建一个数据行的快照时的版本号
2. 删除版本号，


#### Undo日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。
![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585408333610-1585408333698.png)

#### ReadView
当前系统未提交的事务列表TRX_IDs，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX
![title](https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/28/1585408417324-1585408417327.png)

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。

TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。

TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：

提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。
在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。

#### 快照读与当前读
1. 快照读:  select, 在进行 SELECT 操作时，可以强制指定进行加锁操作。
2. 当前读:  INSERT、UPDATE、DELETE
MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。**MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。**


#### MVCC具体实现
**1**.select：满足以下两个条件innodb会返回该行数据： 

 （1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。 
　　

 （2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。 

　　

**2**.insert：将新插入的行的创建版本号设置为当前系统的版本号。 


**3**.delete：将要删除的行的删除版本号设置为当前系统的版本号。 

　　
**4**.update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。 

#### 例子

**以下表格仅为示意图，方便理解**

1). insert操作（事务版本为1）：事务1，插入两行数据

|id|data|创建版本号|删除版本号
|---|---|---|---
|1|事务1.1|1|-
|2|事务1.2|1|-

2). delete操作（事务版本为2）：事务2，删除id为1数据

|id|data|创建版本号|删除版本号
|---|---|---|---
|1|事务1.1|1|2
|2|事务1.2|1|-

3). update操作（事务版本为3）：事务3，更新id为2数据，=>(delete+insert)

|id|data|创建版本号|删除版本号
|---|---|---|---
|1|事务1.1|1|2
|2|事务1.2|1|3
|2|事务3|3|-

4). select操作（事务版本为4）：事务4，查询所有行，返回结果如下，

|id|data|创建版本号|删除版本号
|---|---|---|---
|2|事务3|3|-

5). 两个事务：事务5（查询id=2），事务6（更新id=2）

事务5未执行，事务6执行完

|id|data|创建版本号|删除版本号
|---|---|---|---
|1|事务1.1|1|2
|2|事务1.2|1|3
|2|事务3|3|6
|2|事务6|6|-

事务5执行完，第4行创建版本号6>事务版本号5，第3行创建版本号3<=事务版本号5<=删除版本号,故返回为

|id|data|创建版本号|删除版本号
|---|---|---|---
|2|事务3|3|6


## Next-Key Locks
Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

### Record Locks
锁定一个记录上的索引，而不是记录本身

### Gap Locks
锁定索引之间的间隙，但是不包含索引本身。

### Next-Key Locks
它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，